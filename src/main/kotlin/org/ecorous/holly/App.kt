/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.ecorous.holly

import com.kotlindiscord.kord.extensions.DISCORD_GREEN
import com.kotlindiscord.kord.extensions.ExtensibleBot
import com.kotlindiscord.kord.extensions.utils.env
import dev.kord.common.entity.ButtonStyle
import dev.kord.common.entity.Snowflake
import dev.kord.rest.builder.message.actionRow
import dev.kord.rest.builder.message.embed
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.datetime.*
import org.ecorous.holly.extensions.TestExtension
import org.ecorous.holly.reminders.*
import java.util.Timer
import kotlin.time.Duration.Companion.minutes

val TEST_SERVER_ID = Snowflake(
	env("TEST_SERVER").toLong()  // Get the test server ID from the env vars or a .env file
)

val USER_ID = Snowflake(
	env("USER_ID").toLong()  // Get the user ID from the env vars or a .env file
)

private val TOKEN = env("TOKEN")   // Get the bot' token from the env vars or a .env file

lateinit var bot: ExtensibleBot

@OptIn(DelicateCoroutinesApi::class)
suspend fun main() {
	// use while (true) { ... } to run forever
	// use delay(1000) to wait 1 second between each iteration

	DB.setup()
	bot = ExtensibleBot(TOKEN) {

		extensions {
			add(::TestExtension)
		}
	}

	val timer = Timer()
	// check every 10 seconds
	// this is because 1 minute is the minimum frequency
	// we will always be accurate to within 10 seconds.
	// This is as accurate as we can be without wasting resources.
	/*timer.schedule(0.toLong(), 10000.toLong()) {
		val nextCheck = (Clock.System.now()+ 10.seconds).toLocalDateTime(TimeZone.currentSystemDefault())
		println("Checking reminders...")
		println("Next check: ${nextCheck.hour}:${nextCheck.minute}:${nextCheck.second}")
		GlobalScope.launch {
			Reminders.checkAll()
		}
	}*/
	/*Reminders.schedule(CompletionReminder.new {
		title = "Test Reminder (non-repeating)"
		message = "This is a test reminder!"
		frequency = Frequency(FrequencyType.MINUTE, 1)
		lastCompleted = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
		dueTime = Clock.System.now() + 1.minutes
		completion {
			embed {
				title = "Reminder completed!"
				description = "Your reminder \"${title}\" was completed."
				color = DISCORD_GREEN
			}
		}
	})*/
	Reminders.schedule(CompletionReminder.new {
		title = "Test Reminder (repeating)"
		message = "This is a test reminder!"
		frequency = Frequency(FrequencyType.MINUTE, 2)
		lastCompleted = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault())
		dueTime = Clock.System.now() + 2.minutes
		completion {
			embed {
				title = "Reminder completed!"
				description = "Your reminder \"${title}\" was completed."
				color = DISCORD_GREEN
			}
			actionRow {
				interactionButton(ButtonStyle.Success, "disabled") {
					label = "Complete"
					disabled = true
				}
			}
		}
	})
	bot.start()
}

val LocalDateTime.timeFormat: String // should be HH:MM:SS
	get() = "${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:${second.toString().padStart(2, '0')}"

val LocalDateTime.dateFormat: String// should be DD/MM/YYYY
	get() = "${dayOfMonth.toString().padStart(2, '0')}/${monthNumber.toString().padStart(2, '0')}/${year}"

val LocalDateTime.dateTimeFormat: String
	get() = "$dateFormat $timeFormat"
